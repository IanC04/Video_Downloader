try:
    from pytube import YouTube
    import pytube.exceptions
except ModuleNotFoundError:
    # the batch file should have downloaded pytube to the venv using the GitHub's
    # requirements.txt generated by (pip freeze > requirements.txt)
    print('pytube library is not installed. Please delete files and download again.')
    exit()
import tkinter as tk
from tkinter import filedialog, ttk
import os
import signal

signal.signal(signal.SIGINT, signal.SIG_DFL)
del signal

RELEASE_DATE = f'May 03, 2024'


class Downloader(tk.Tk):
    """
    Main class for downloading YouTube videos.
    """
    if os.name == "nt":
        DEFAULT_SAVE_LOCATION = f'{os.getenv('USERPROFILE')}\\Downloads'
    else:  # PORT: For *Nix systems
        DEFAULT_SAVE_LOCATION = f'{os.getenv('HOME')}/Downloads'

    # Can't go above 720p due to Progressive and DASH streams:
    # https://pytube.io/en/latest/user/streams.html#filtering-by-streaming-method
    QUALITIES = ['144p', '240p', '360p', '480p', '720p', '1080p', '1440p', '2160p']
    QUALITY_MAP = {q: n for n, q in enumerate(QUALITIES)}

    def __init__(self):
        super().__init__()
        self._url = None
        self._yt = None
        self._video = None
        self._save_directory = None
        self._output_file = None

        ws = self.winfo_screenwidth() // 3  # width of the screen
        hs = self.winfo_screenheight() // 3  # height of the screen
        self.geometry(f'+{ws}+{hs}')
        self.title('YouTube Downloader')
        try:
            if os.path.isfile('icon.ico'):
                self.wm_iconbitmap('icon.ico')
        except tk.TclError:
            print(f'Bug in setting window icon image')
        self.resizable(False, False)
        self.focus_force()
        self._frame = ttk.Frame(self, padding=12)
        self._frame.grid(row=0, column=0)

        # Main Center Label
        self._label_text = tk.StringVar()
        self._label = tk.Label(self._frame, textvariable=self._label_text, justify=tk.CENTER,
                               font=('Courier', 14), fg='black', width=75,
                               wraplength=self.winfo_pixels(ws))
        self._label.grid(row=0, columnspan=2)

        # Input box to type link
        self._input_box = tk.Entry(self._frame, width=40, bg='light yellow', font=('Arial', 14),
                                   fg='blue', state=tk.DISABLED)
        self._input_box.grid(row=1, columnspan=2)

        # Move buttons
        self._back = tk.Button(self._frame, text='Back', width=10, height=1, state=tk.DISABLED)
        self._back.grid(row=2, column=0, sticky=tk.E)
        self._next = tk.Button(self._frame, text='Start', width=10, height=1, command=self.get_url)
        self._next.grid(row=2, column=1, sticky=tk.W)

        # Quality control and video/audio
        self._av = ttk.Combobox(self._frame, state='readonly', values=['Video', 'Audio'])
        self._av.set(value=self._av['values'][0])
        self._av.grid(row=3, column=0, sticky=tk.E)
        self._qc = ttk.Combobox(self._frame, state='readonly',
                                values=self.QUALITIES)
        self._qc.set(value=self._qc['values'][2])
        self._qc.bind("<<ComboboxSelected>>", self.combo_click)
        self._qc.grid(row=3, column=1, sticky=tk.W)

        # Tip label
        self._tip_text = tk.StringVar()
        self._tip = tk.Label(self._frame, textvariable=self._tip_text, justify=tk.LEFT)
        self._tip.grid(row=4, columnspan=2, sticky=tk.W)

        # Exit button
        leave = tk.Button(self._frame, text='Exit',
                          command=self.destroy)
        leave.grid(row=5, column=1, sticky=tk.E)

        self.reset()

    def combo_click(self, event):
        if self.QUALITY_MAP[self._qc.get().strip()] > self.QUALITY_MAP['720p']:
            self._tip_text.set('Tip: Can\'t get videos with quality higher then 720p '
                               'resolution due to technical reasons. Will attempt to grab the '
                               'highest possible quality <=720p.')

    def get_url(self) -> None:
        self._label_text.set("Enter the URL of the video you want to download.")
        self._input_box.config(state=tk.NORMAL)
        self._input_box.bind("<KeyRelease>", lambda event: self.check_url())
        self._tip_text.set('Tip: Right-Click on Thumbnail of a YouTube video then click \"copy '
                           'link\"')

        self._back.config(command=self.reset, state=tk.NORMAL)
        self._next.config(text="Confirm", command=self.confirm_url, state=tk.NORMAL)
        self._input_box.focus_force()

    def check_url(self) -> None:
        self._url = self._input_box.get().strip()
        if self._url == '':
            self._tip_text.set('Tip: Please type in a URL into the yellow box. Use Ctrl + V to '
                               'paste.')
        else:
            try:
                self._yt = YouTube(self._url)
                self._tip_text.set(f'Found video: {self._yt.title}')
            except pytube.exceptions.RegexMatchError:
                self._tip_text.set('Tip: Video not found. Continue typing...')

    def confirm_url(self) -> None:
        if self._yt is None:
            self._tip_text.set('Tip: Invalid URL. Please try again. Make sure entire link is '
                               'pasted correctly!')
            return
        self._input_box.delete(0, tk.END)
        self._input_box.config(state=tk.DISABLED)
        self._input_box.unbind('<KeyRelease>')
        self._tip_text.set('Tip: Please wait as the download begins.')
        self.try_extract_video()

    def try_extract_video(self) -> None:
        self._label_text.set('Extracting Video')
        self._back.config(command=self.get_url)
        self._next.config(state=tk.DISABLED)
        try:
            if self._av.get().strip() == 'Video':
                # Get video file and selected quality
                videos = self._yt.streams.filter(file_extension='mp4')
                chosen_res = self._qc.get().strip()
                self._video = videos.get_by_resolution(chosen_res)
                while self._video is None:
                    if chosen_res == '144p':
                        self._tip_text.set('Tip: No lower resolutions available.')
                        return
                    chosen_res = self.QUALITIES[self.QUALITY_MAP[chosen_res] - 1]
                    self._video = videos.get_by_resolution(chosen_res)
                    self._tip_text.set('Tip: Unable to download chosen quality, getting next best '
                                       'resolution available')
                self.get_save_directory()
            else:
                # Get audio file
                audios = self._yt.streams.filter(only_audio=True)
                self._video = audios.first()
                if self._video is None:
                    self._label_text.set('Sorry, audio file not found')
                    self._tip_text.set('Tip: Unable to download the music.')
                    return
                self.get_save_directory()
        except pytube.exceptions.AgeRestrictedError:
            self._label_text.set('Sorry, Video is age restricted')
            self._tip_text.set('Tip: Can\'t download age restricted videos without logging in.')
        except pytube.exceptions.PytubeError:
            self._label_text.set('Please try again with different video.')
            self._tip_text.set('Tip: Internal error! Only downloads as mp4.')

    def get_save_directory(self) -> None:
        self._save_directory = self.DEFAULT_SAVE_LOCATION

        self._label_text.set('Select a directory to save the video')
        self._tip_text.set('Tip: You can press Ctrl + V to paste the path into the dialog window '
                           'or just close the window for the default directory.')
        destination = tk.filedialog.askdirectory(initialdir=self.DEFAULT_SAVE_LOCATION,
                                                 mustexist=True,
                                                 title='Select a directory to save the video')
        if destination == '':
            self._label_text.set(f'Using default directory: {self._save_directory}')
        elif os.path.isdir(destination):
            self._save_directory = destination
        else:
            self._label_text.set(f'Directory {destination} does not exist.')
            return self.get_save_directory()
        self.start_download()

    def start_download(self) -> None:
        self._label_text.set('Downloading...')
        self._output_file = self._video.download(output_path=self._save_directory)
        self.confirm_success()

    def confirm_success(self) -> None:
        self._label_text.set('Download Complete!')
        self._tip_text.set(f'{self._video.title} has been successfully downloaded to '
                           f'{self._output_file}.')
        self._back.config(text='View File', command=lambda: os.startfile(f'{self._output_file}'))
        self._next.config(text='Again!', command=self.reset, state=tk.NORMAL)

    def reset(self) -> None:
        self._label_text.set(f'YouTube Downloader | Last updated {RELEASE_DATE} by Ian')
        self._input_box.config(state=tk.DISABLED)
        self._input_box.delete(0, tk.END)
        self._input_box.unbind('<KeyRelease>')

        self._back.config(text='Back', state=tk.DISABLED)
        self._next.config(text='Next', command=self.get_url, state=tk.NORMAL)
        self._tip_text.set('Tip: You can press Ctrl + V to paste the URL.')

        self._url = None
        self._yt = None
        self._video = None
        self._save_directory = None
        self._output_file = None


downloader = Downloader()
downloader.mainloop()
